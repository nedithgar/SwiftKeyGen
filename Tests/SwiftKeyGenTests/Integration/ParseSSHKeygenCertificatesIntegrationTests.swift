import Testing
@testable import SwiftKeyGen
import Foundation

/// Integration tests for parsing SSH certificates generated by ssh-keygen.
///
/// These tests ensure we can parse, extract metadata from, and verify certificates
/// created by OpenSSH's ssh-keygen, including all supported CA key types and
/// certificate options.
@Suite("Parse ssh-keygen Generated Certificates", .tags(.integration))
struct ParseSSHKeygenCertificatesIntegrationTests {
    
    // MARK: - User Certificates - Ed25519 CA
    
    @Test("Parse ssh-keygen user certificate (Ed25519 CA)")
    func testParseUserCertificateEd25519CA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ed25519")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ed25519-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "CA key generation failed")
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded, "User key generation failed")
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "test-user-cert",
                "-n", "alice,bob",
                "-V", "+1h",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "test-user-cert", "Key ID should match")
            #expect(cert.type == .user, "Certificate type should be user")
            #expect(cert.principals.contains("alice"), "Should contain principal 'alice'")
            #expect(cert.principals.contains("bob"), "Should contain principal 'bob'")
            #expect(cert.principals.count == 2, "Should have 2 principals")
            
            // Verify CA key type (public-only)
            #expect(cert.signatureKey is Ed25519PublicKey, "CA key should be Ed25519PublicKey")
        }
    }
    
    // MARK: - User Certificates - RSA CA
    
    @Test("Parse ssh-keygen user certificate (RSA CA with rsa-sha2-256)", .tags(.rsa))
    func testParseUserCertificateRSACAWithSHA256() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate RSA CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_rsa")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "rsa",
                "-b", "2048",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "rsa-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "RSA CA key generation failed")
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded, "User key generation failed")
            
            // Sign certificate with rsa-sha2-256
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "rsa-sha256-cert",
                "-n", "charlie",
                "-t", "rsa-sha2-256",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing with rsa-sha2-256 failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "rsa-sha256-cert", "Key ID should match")
            #expect(cert.type == .user, "Certificate type should be user")
            #expect(cert.principals.contains("charlie"), "Should contain principal 'charlie'")
            #expect(cert.signatureType == "rsa-sha2-256", "Signature type should be rsa-sha2-256")
            
            // Verify CA key type (public-only)
            #expect(cert.signatureKey is RSAPublicKey, "CA key should be RSAPublicKey")
        }
    }

    @Test("Parse ssh-keygen user certificate (RSA CA with rsa-sha2-512)", .tags(.rsa))
    func testParseUserCertificateRSACAWithSHA512() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate RSA CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_rsa")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "rsa",
                "-b", "2048",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "rsa-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "RSA CA key generation failed")
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded, "User key generation failed")
            
            // Sign certificate with rsa-sha2-512 (default for modern ssh-keygen)
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "rsa-sha512-cert",
                "-n", "dave",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "rsa-sha512-cert", "Key ID should match")
            #expect(cert.type == .user, "Certificate type should be user")
            #expect(cert.principals.contains("dave"), "Should contain principal 'dave'")
            
            // Verify CA key type (public-only)
            #expect(cert.signatureKey is RSAPublicKey, "CA key should be RSAPublicKey")
        }
    }
    
    // MARK: - User Certificates - ECDSA CAs
    
    @Test("Parse ssh-keygen user certificate (ECDSA P-256 CA)")
    func testParseUserCertificateECDSAP256CA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate ECDSA P-256 CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ecdsa_p256")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ecdsa",
                "-b", "256",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ecdsa-p256-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "ECDSA P-256 CA key generation failed")
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded, "User key generation failed")
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "ecdsa-p256-cert",
                "-n", "eve",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "ecdsa-p256-cert", "Key ID should match")
            #expect(cert.type == .user, "Certificate type should be user")
            #expect(cert.principals.contains("eve"), "Should contain principal 'eve'")
            
            // Verify CA key type and curve (public-only)
            #expect(cert.signatureKey is ECDSAPublicKey, "CA key should be ECDSAPublicKey")
            let ecdsaCA = cert.signatureKey as! ECDSAPublicKey
            #expect(ecdsaCA.keyType == .ecdsa256, "CA key type should be ecdsa256")
        }
    }
    
    @Test("Parse ssh-keygen user certificate (ECDSA P-384 CA)")
    func testParseUserCertificateECDSAP384CA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate ECDSA P-384 CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ecdsa_p384")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ecdsa",
                "-b", "384",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ecdsa-p384-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "ECDSA P-384 CA key generation failed")
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded, "User key generation failed")
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "ecdsa-p384-cert",
                "-n", "frank",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "ecdsa-p384-cert", "Key ID should match")
            #expect(cert.type == .user, "Certificate type should be user")
            #expect(cert.principals.contains("frank"), "Should contain principal 'frank'")
            
            // Verify CA key type and curve (public-only)
            #expect(cert.signatureKey is ECDSAPublicKey, "CA key should be ECDSAPublicKey")
            let ecdsaCA = cert.signatureKey as! ECDSAPublicKey
            #expect(ecdsaCA.keyType == .ecdsa384, "CA curve should be P-384")
        }
    }
    
    @Test("Parse ssh-keygen user certificate (ECDSA P-521 CA)")
    func testParseUserCertificateECDSAP521CA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate ECDSA P-521 CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ecdsa_p521")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ecdsa",
                "-b", "521",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ecdsa-p521-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "ECDSA P-521 CA key generation failed")
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded, "User key generation failed")
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "ecdsa-p521-cert",
                "-n", "grace",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "ecdsa-p521-cert", "Key ID should match")
            #expect(cert.type == .user, "Certificate type should be user")
            #expect(cert.principals.contains("grace"), "Should contain principal 'grace'")
            
            // Verify CA key type and curve (public-only)
            #expect(cert.signatureKey is ECDSAPublicKey, "CA key should be ECDSAPublicKey")
            let ecdsaCA = cert.signatureKey as! ECDSAPublicKey
            #expect(ecdsaCA.keyType == .ecdsa521, "CA curve should be P-521")
        }
    }
    
    // MARK: - Host Certificates
    
    @Test("Parse ssh-keygen host certificate (Ed25519 CA)")
    func testParseHostCertificateEd25519CA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ed25519")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "host-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "CA key generation failed")
            
            // Generate host key
            let hostKeyPath = tempDir.appendingPathComponent("host_key")
            let hostGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", hostKeyPath.path,
                "-N", "",
                "-C", "host@example.com"
            ])
            #expect(hostGenResult.succeeded, "Host key generation failed")
            
            // Sign host certificate
            let certPath = hostKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "host-cert",
                "-n", "server.example.com,10.0.0.1",
                "-h",  // Host certificate flag
                certPath.path
            ])
            #expect(signResult.succeeded, "Host certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("host_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "host-cert", "Key ID should match")
            #expect(cert.type == .host, "Certificate type should be host")
            #expect(cert.principals.contains("server.example.com"), "Should contain hostname principal")
            #expect(cert.principals.contains("10.0.0.1"), "Should contain IP address principal")
        }
    }

    @Test("Parse ssh-keygen host certificate (RSA CA)", .tags(.rsa))
    func testParseHostCertificateRSACA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate RSA CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_rsa")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "rsa",
                "-b", "2048",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "host-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "RSA CA key generation failed")
            
            // Generate host key
            let hostKeyPath = tempDir.appendingPathComponent("host_key")
            let hostGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", hostKeyPath.path,
                "-N", "",
                "-C", "host@example.com"
            ])
            #expect(hostGenResult.succeeded, "Host key generation failed")
            
            // Sign host certificate
            let certPath = hostKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "rsa-host-cert",
                "-n", "web.example.com",
                "-h",
                certPath.path
            ])
            #expect(signResult.succeeded, "Host certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("host_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "rsa-host-cert", "Key ID should match")
            #expect(cert.type == .host, "Certificate type should be host")
            #expect(cert.principals.contains("web.example.com"), "Should contain hostname principal")
            #expect(cert.signatureKey is RSAPublicKey, "CA key should be RSAPublicKey")
        }
    }
    
    @Test("Parse ssh-keygen host certificate (ECDSA P-256 CA)")
    func testParseHostCertificateECDSACA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate ECDSA CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ecdsa")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ecdsa",
                "-b", "256",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "host-ca@example.com"
            ])
            #expect(caGenResult.succeeded, "ECDSA CA key generation failed")
            
            // Generate host key
            let hostKeyPath = tempDir.appendingPathComponent("host_key")
            let hostGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", hostKeyPath.path,
                "-N", "",
                "-C", "host@example.com"
            ])
            #expect(hostGenResult.succeeded, "Host key generation failed")
            
            // Sign host certificate
            let certPath = hostKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "ecdsa-host-cert",
                "-n", "api.example.com",
                "-h",
                certPath.path
            ])
            #expect(signResult.succeeded, "Host certificate signing failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("host_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify certificate fields
            let cert = certifiedKey.certificate
            #expect(cert.keyId == "ecdsa-host-cert", "Key ID should match")
            #expect(cert.type == .host, "Certificate type should be host")
            #expect(cert.principals.contains("api.example.com"), "Should contain hostname principal")
            #expect(cert.signatureKey is ECDSAPublicKey, "CA key should be ECDSAPublicKey")
        }
    }
    
    // MARK: - Certificate Metadata
    
    @Test("Extract all certificate fields correctly")
    func testExtractAllCertificateFields() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate CA and user keys
            let caKeyPath = tempDir.appendingPathComponent("ca_key")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ca@example.com"
            ])
            #expect(caGenResult.succeeded)
            
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded)
            
            // Sign with specific serial, validity, and principals
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "metadata-test",
                "-n", "principal1,principal2,principal3",
                "-z", "12345",  // Serial number
                "-V", "+52w",   // Valid for 52 weeks
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing failed")
            
            // Parse and verify all fields
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            let cert = certifiedKey.certificate
            
            // Verify serial number
            #expect(cert.serial == 12345, "Serial number should match")
            
            // Verify key ID
            #expect(cert.keyId == "metadata-test", "Key ID should match")
            
            // Verify principals
            #expect(cert.principals.count == 3, "Should have 3 principals")
            #expect(cert.principals.contains("principal1"), "Should contain principal1")
            #expect(cert.principals.contains("principal2"), "Should contain principal2")
            #expect(cert.principals.contains("principal3"), "Should contain principal3")
            
            // Verify validity period is set
            #expect(cert.validAfter > 0, "Valid after should be set")
            #expect(cert.validBefore > cert.validAfter, "Valid before should be after valid after")
            
            // Verify certificate type
            #expect(cert.type == .user, "Certificate type should be user")
        }
    }
    
    // MARK: - Certificate with Critical Options
    
    @Test("Parse certificates with critical options")
    func testParseCertificateWithCriticalOptions() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate CA and user keys
            let caKeyPath = tempDir.appendingPathComponent("ca_key")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ca@example.com"
            ])
            #expect(caGenResult.succeeded)
            
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded)
            
            // Sign with critical options (force-command and source-address)
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "restricted-cert",
                "-n", "restricted-user",
                "-O", "force-command=/usr/bin/ls",
                "-O", "source-address=10.0.0.0/8",
                certPath.path
            ])
            #expect(signResult.succeeded, "Certificate signing with critical options failed")
            
            // Parse the certificate
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            let cert = certifiedKey.certificate
            
            // Verify critical options are present
            #expect(cert.criticalOptions.count >= 2, "Should have at least 2 critical options")
            
            // Check for force-command
            let hasForceCommand = cert.criticalOptions.contains { option in
                option.0 == "force-command"
            }
            #expect(hasForceCommand, "Should have force-command critical option")
            
            // Check for source-address
            let hasSourceAddress = cert.criticalOptions.contains { option in
                option.0 == "source-address"
            }
            #expect(hasSourceAddress, "Should have source-address critical option")
        }
    }
    
    // MARK: - Signature Verification
    
    @Test("Verify signature on ssh-keygen certificate (Ed25519)")
    func testVerifySSHKeygenCertificateSignature() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_key")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ca@example.com"
            ])
            #expect(caGenResult.succeeded)
            
            // Read CA key for verification
            let caKey = try KeyManager.readPrivateKey(from: caKeyPath.path, passphrase: nil)
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded)
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "verify-test",
                "-n", "testuser",
                certPath.path
            ])
            #expect(signResult.succeeded)
            
            // Parse and verify certificate signature
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify signature using CertificateVerifier
            let result = CertificateVerifier.verifyCertificate(
                certifiedKey,
                caKey: caKey
            )
            
            #expect(result == .valid, "Certificate signature should be valid")
        }
    }

    @Test("Verify signature on ssh-keygen certificate (RSA)", .tags(.rsa))
    func testVerifySSHKeygenCertificateSignatureRSA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate RSA CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_rsa")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "rsa",
                "-b", "2048",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "rsa-ca@example.com"
            ])
            #expect(caGenResult.succeeded)
            
            // Read CA key for verification
            let caKey = try KeyManager.readPrivateKey(from: caKeyPath.path, passphrase: nil)
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded)
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "rsa-verify-test",
                "-n", "testuser",
                certPath.path
            ])
            #expect(signResult.succeeded)
            
            // Parse and verify certificate signature
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify signature
            let result = CertificateVerifier.verifyCertificate(
                certifiedKey,
                caKey: caKey
            )
            
            #expect(result == .valid, "RSA certificate signature should be valid")
        }
    }
    
    @Test("Verify signature on ssh-keygen certificate (ECDSA P-256)")
    func testVerifySSHKeygenCertificateSignatureECDSA() throws {
        try IntegrationTestSupporter.withTemporaryDirectory { tempDir in
            // Generate ECDSA CA key
            let caKeyPath = tempDir.appendingPathComponent("ca_ecdsa")
            let caGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ecdsa",
                "-b", "256",
                "-f", caKeyPath.path,
                "-N", "",
                "-C", "ecdsa-ca@example.com"
            ])
            #expect(caGenResult.succeeded)
            
            // Read CA key for verification
            let caKey = try KeyManager.readPrivateKey(from: caKeyPath.path, passphrase: nil)
            
            // Generate user key
            let userKeyPath = tempDir.appendingPathComponent("user_key")
            let userGenResult = try IntegrationTestSupporter.runSSHKeygen([
                "-t", "ed25519",
                "-f", userKeyPath.path,
                "-N", "",
                "-C", "user@example.com"
            ])
            #expect(userGenResult.succeeded)
            
            // Sign certificate
            let certPath = userKeyPath.appendingPathExtension("pub")
            let signResult = try IntegrationTestSupporter.runSSHKeygen([
                "-s", caKeyPath.path,
                "-I", "ecdsa-verify-test",
                "-n", "testuser",
                certPath.path
            ])
            #expect(signResult.succeeded)
            
            // Parse and verify certificate signature
            let certFilePath = tempDir.appendingPathComponent("user_key-cert.pub")
            let certString = try String(contentsOf: certFilePath, encoding: .utf8)
            let certifiedKey = try CertificateParser.parseCertificate(from: certString)
            
            // Verify signature
            let result = CertificateVerifier.verifyCertificate(
                certifiedKey,
                caKey: caKey
            )
            
            #expect(result == .valid, "ECDSA certificate signature should be valid")
        }
    }
}
