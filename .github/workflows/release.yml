name: Release

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  preflight:
    name: Preflight Version & Release Check
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract.outputs.version }}
      tag: ${{ steps.extract.outputs.tag }}
      release_exists: ${{ steps.check_release.outputs.release_exists }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract Version from main.swift
        id: extract
        shell: bash
        run: |
          set -euo pipefail
          LINE=$(grep -E 'private static let version = "' Sources/SwiftKeyGenCLI/main.swift || true)
          if [[ -z "$LINE" ]]; then
            echo "Could not locate version constant in main.swift" >&2
            exit 1
          fi
            VERSION=$(sed -E 's/.*version = "([^"]+)".*/\1/' <<< "$LINE")
          if [[ -z "$VERSION" ]]; then
            echo "Failed to parse version string" >&2
            exit 1
          fi
          TAG="v${VERSION}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Parsed version: $VERSION (tag: $TAG)"

      - name: Tag Strategy Note
        shell: bash
        run: |
          echo "No git tag precondition. Version in main.swift governs the release."
          echo "If tag ${{ steps.extract.outputs.tag }} is absent, the release job will create it automatically."

      - name: Check for Existing Release
        id: check_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          TAG="${{ steps.extract.outputs.tag }}"
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "$API_URL")
          if [[ "$STATUS" == "200" ]]; then
            echo "Release for ${TAG} already exists." >&2
            echo "release_exists=true" >> $GITHUB_OUTPUT
          else
            echo "No existing release for ${TAG}. Proceeding." 
            echo "release_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Compare with Previous Release (fail if version decreased)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          set -euo pipefail
          NEW_VER="${{ steps.extract.outputs.version }}"
          # Fetch releases (paginated: only first page needed for latest)
          JSON=$(curl -s -H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases?per_page=20")
          if command -v jq >/dev/null 2>&1; then
            PREV_TAG=$(echo "$JSON" | jq -r '[.[] | select(.draft==false and .prerelease==false) | .tag_name] | map(select(startswith("v"))) | .[0]') || true
          else
            PREV_TAG=$(echo "$JSON" | grep -E '"tag_name"' | head -n1 | sed -E 's/.*"tag_name": "([^"]+)".*/\1/' || true)
          fi
          if [[ -z "$PREV_TAG" || "$PREV_TAG" == "null" ]]; then
            echo "No previous release found; skipping downgrade check."; exit 0
          fi
          PREV_VER=${PREV_TAG#v}
          echo "Previous release: $PREV_VER; New: $NEW_VER"
          ver_to_nums() { IFS='.' read -r a b c <<< "$1"; echo "${a:-0} ${b:-0} ${c:-0}"; }
          read -r pA pB pC <<< $(ver_to_nums "$PREV_VER")
          read -r nA nB nC <<< $(ver_to_nums "$NEW_VER")
          if (( nA < pA )) || { (( nA == pA )) && (( nB < pB )); } || { (( nA == pA )) && (( nB == pB )) && (( nC < pC )); }; then
            echo "Version regression detected: $NEW_VER < $PREV_VER" >&2
            exit 1
          fi
          echo "Version is not a downgrade."

  build:
    name: Build Release Binaries (${{ matrix.os }})
    needs: preflight
    if: needs.preflight.outputs.release_exists == 'false'
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-26]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Swift 6.2 (Linux)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euxo pipefail
          SWIFT_VERSION=6.2

          # If the required Swift version is already available, skip installation.
          if swift --version 2>/dev/null | grep -q "Swift version ${SWIFT_VERSION}"; then
            echo "Swift ${SWIFT_VERSION} already installed on runner."
          else
            # Install Swiftly (official Swift.org installer/manager) and use it to install Swift ${SWIFT_VERSION}
            ARCH="$(uname -m)"
            SWIFTLY_TARBALL="swiftly-${ARCH}.tar.gz"
            curl -fSLo "${SWIFTLY_TARBALL}" "https://download.swift.org/swiftly/linux/${SWIFTLY_TARBALL}"
            tar zxf "${SWIFTLY_TARBALL}"
            ./swiftly init --quiet-shell-followup
            # Load environment so 'swiftly' is available in this step
            . "${SWIFTLY_HOME_DIR:-$HOME/.local/share/swiftly}/env.sh"
            # Install exact Swift version
            swiftly install "${SWIFT_VERSION}"
            # Persist Swiftly bin path for subsequent steps
            echo "${SWIFTLY_HOME_DIR:-$HOME/.local/share/swiftly}/bin" >> "$GITHUB_PATH"
            hash -r
          fi

          swift --version

      - name: Install Swift 6.2 (macOS)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euxo pipefail
          SWIFT_VERSION=6.2
          PKG="swift-${SWIFT_VERSION}-RELEASE-osx.pkg"
          URL="https://download.swift.org/swift-${SWIFT_VERSION}-release/xcode/swift-${SWIFT_VERSION}-RELEASE/${PKG}"
          curl -fSOL "$URL"
          sudo installer -pkg "$PKG" -target /
          TOOLCHAIN="/Library/Developer/Toolchains/swift-${SWIFT_VERSION}-RELEASE.xctoolchain/usr/bin"
          echo "$TOOLCHAIN" >> "$GITHUB_PATH"
          swift --version

      - name: Print Swift Version
        run: swift --version

      - name: Resolve Dependencies
        run: swift package resolve

      - name: Build (Release)
        run: swift build -c release

      - name: Package Artifact
        id: package
        shell: bash
        run: |
          mkdir -p dist
          BIN_PATH=".build/release/swiftkeygen"
          cp "$BIN_PATH" "dist/"
          cp LICENSE dist/ || true
          ARCHIVE_NAME="swiftkeygen-${{ needs.preflight.outputs.version }}-${{ runner.os }}.tar.gz"
          tar -czf "$ARCHIVE_NAME" -C dist .
          # Generate SHA256 checksum (portable)
          if command -v shasum >/dev/null 2>&1; then
            shasum -a 256 "$ARCHIVE_NAME" > "$ARCHIVE_NAME".sha256
          elif command -v sha256sum >/dev/null 2>&1; then
            sha256sum "$ARCHIVE_NAME" > "$ARCHIVE_NAME".sha256
          else
            echo "No SHA256 tool found" >&2; exit 1
          fi
          cat "$ARCHIVE_NAME".sha256
          echo "archive=$ARCHIVE_NAME" >> $GITHUB_OUTPUT

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.package.outputs.archive }}
          path: |
            ${{ steps.package.outputs.archive }}
            ${{ steps.package.outputs.archive }}.sha256

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [preflight, build]
    if: needs.preflight.outputs.release_exists == 'false'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Gather Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: swiftkeygen-*.tar.gz*
          merge-multiple: true

      - name: List Artifacts
        run: ls -alR

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.preflight.outputs.tag }}
          name: SwiftKeyGen ${{ needs.preflight.outputs.tag }}
          draft: false
          prerelease: false
          target_commitish: ${{ github.sha }}
          generate_release_notes: true
          files: |
            **/swiftkeygen-*.tar.gz
            **/swiftkeygen-*.tar.gz.sha256
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  update-changelog:
    name: Update CHANGELOG with release notes
    runs-on: ubuntu-latest
    needs: [preflight, create-release]
    if: needs.preflight.outputs.release_exists == 'false'
    steps:
      - name: Update CHANGELOG.md using generated release notes
        shell: bash
        env:
          GITHUB_TOKEN: ${{ github.token }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          TOKEN="${GITHUB_TOKEN:-${GH_TOKEN:-}}"
          if [[ -z "$TOKEN" ]]; then
            echo "No GitHub token available in environment (GITHUB_TOKEN/GH_TOKEN)." >&2
            exit 1
          fi

          VERSION="${{ needs.preflight.outputs.version }}"
          TAG="${{ needs.preflight.outputs.tag }}"
          DATE=$(date -u +%Y-%m-%d)
          REF_NAME="${{ github.ref_name }}"

          # Ensure jq is available for JSON handling
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y >/dev/null 2>&1 || true
            sudo apt-get install -y jq >/dev/null 2>&1 || true
          fi

          # Fetch the created release by tag and extract the auto-generated body
          REL_API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          REL_JSON=$(curl -sS -H "Authorization: Bearer $TOKEN" -H "Accept: application/vnd.github+json" "$REL_API")
          BODY=$(echo "$REL_JSON" | jq -r '.body // empty')
          if [[ -z "$BODY" ]]; then
            echo "Release body is empty; nothing to append to CHANGELOG. Skipping."
            exit 0
          fi

          # Get existing CHANGELOG.md (if any) from the branch
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/CHANGELOG.md"
          EXISTING_JSON=$(curl -s -H "Authorization: Bearer $TOKEN" -H "Accept: application/vnd.github+json" "${API}?ref=${REF_NAME}" || true)
          SHA=$(echo "$EXISTING_JSON" | jq -r '.sha // empty')
          CONTENT_B64=$(echo "$EXISTING_JSON" | jq -r '.content // empty')
          ENCODING=$(echo "$EXISTING_JSON" | jq -r '.encoding // empty')

          if [[ -n "$CONTENT_B64" && "$ENCODING" == "base64" ]]; then
            EXISTING=$(echo "$CONTENT_B64" | tr -d '\n' | base64 -d)
          else
            EXISTING=""
          fi

          # Skip if section already exists
          if grep -Eq "^## ${VERSION}( | -)" <<< "$EXISTING"; then
            echo "CHANGELOG already contains section for $VERSION; skipping update."
            exit 0
          fi

          # Normalize to ensure a single top-level header
          if grep -q "^# Changelog" <<< "$EXISTING"; then
            EXISTING_NO_HEADER=$(echo "$EXISTING" | sed '1{/^# Changelog$/d;}' | sed '1{/^$/d;}')
          else
            EXISTING_NO_HEADER="$EXISTING"
          fi

          NEW_SECTION="## $VERSION - $DATE\n\n$BODY\n\n"
          NEW_CONTENT="# Changelog\n\n${NEW_SECTION}${EXISTING_NO_HEADER}"

          # Base64 encode content without line wraps (portable across GNU/BSD)
          if base64 --help 2>&1 | grep -q "-w"; then
            B64=$(printf "%s" "$NEW_CONTENT" | base64 -w 0)
          else
            B64=$(printf "%s" "$NEW_CONTENT" | base64 | tr -d '\n')
          fi

          # Prepare payload for GitHub API
          PAYLOAD=$(jq -n \
            --arg msg "chore: update CHANGELOG with generated release notes for v$VERSION" \
            --arg content "$B64" \
            --arg branch "$REF_NAME" \
            --arg sha "$SHA" \
            '({message:$msg, content:$content, branch:$branch}) as $base
             | if ($sha|length) > 0 then $base + {sha:$sha} else $base end')

          RESP=$(curl -sS -X PUT -H "Authorization: Bearer $TOKEN" -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" "$API" -d "$PAYLOAD")

          HEAD_SHA=$(echo "$RESP" | jq -r '.commit.sha // empty')
          if [[ -z "$HEAD_SHA" ]]; then
            echo "Failed to update CHANGELOG via API" >&2
            echo "$RESP" >&2
            exit 1
          fi
          echo "CHANGELOG updated at commit $HEAD_SHA"


  release-exists-note:
    name: Release Already Exists (Skip)
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.release_exists == 'true'
    steps:
      - name: Note
        run: echo "Release for tag ${{ needs.preflight.outputs.tag }} already exists. Skipping build and publish."
